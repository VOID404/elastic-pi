(defpackage pi-estimator
  (:use :cl :iterate)
  (:export :pi-calc))
(in-package :pi-estimator)

(declaim (inline transfer-momentum))
(defun transfer-momentum (m1 m2 v1 v2)
  (declare (optimize (speed 3) (safety 0) (debug 0))
           (double-float m1 m2 v1 v2))
  (let ((v1out (+ (* v1 (/ (- m1 m2) (+ m1 m2)))
                  (* v2 (/ (* 2 m2) (+ m1 m2)))))
        (v2out (+ (* v1 (/ (* 2 m1) (+ m1 m2)))
                  (* v2 (/ (- m2 m1) (+ m1 m2))))))
    (values v1out v2out)))

(defun simulate (m1 m2)
  (declare (optimize (speed 3) (safety 0) (debug 0)))
  (iterate
    (with m1 = (coerce m1 'double-float))
    (with m2 = (coerce m2 'double-float))
    (with v1 = (coerce 0 'double-float))
    (with v2 = (coerce -1000 'double-float))
    (with i = 0)
    (until (and (plusp v1)
                (<= v1 v2)))
    (setf (values v1 v2) (if (< v1 0)
                             (values (- v1) v2)
                             (transfer-momentum m1 m2 v1 v2)))
    (incf i)
    (finally (return i))))

(defun pi-calc (&optional (positions 4))
  (coerce (/ (simulate 1 (* 1 (expt 100 positions)))
            (expt 10 positions))
          'double-float))

(defun pi-calc-fast (&optional (p 9))
  (eval `(defun %pi-calc (&aux (positions ,p))
           (declare (optimize (speed 3) (safety 0) (debug 0))
                    (type (unsigned-byte 8) positions))
           (let* ((power-of-ten (expt 10d0 positions))
                  (m1 1d0)
                  (m2 (expt power-of-ten 2))
                  (v1 1d0)
                  (v2 -1000d0))
             (declare (double-float m1 m2 v1 v2 power-of-ten))
             (/ (do ((i 0d0 (1+ i)))
                    ((<= 0d0 v1 v2) i)
                  (declare (double-float i))
                  (if (minusp v1)
                      (setf v1 (- v1))
                      (psetf v1 (+ (* v1 (/ (- m1 m2)
                                            (+ m1 m2)))
                                   (* v2 (/ (* 2 m2)
                                            (+ m1 m2))))
                             v2 (+ (* v1 (/ (* 2 m1)
                                            (+ m1 m2)))
                                   (* v2 (/ (- m2 m1)
                                            (+ m1 m2)))))))
                power-of-ten))))
  (%pi-calc))

(defun pi-calc-loop (&optional (positions 9))
  (declare (optimize (speed 3) (safety 0) (debug 0))
           (type (unsigned-byte 8) positions))
  (let* ((power-of-ten (expt 10d0 positions))
         (m1 1d0)
         (m2 (expt power-of-ten 2))
         (v1 1d0)
         (v2 -1000d0)
         (a (* (- m1 m2) (/ (+ m1 m2))))
         (b (* 2 m2 (/ (+ m1 m2))))
         (c (* 2 m1 (/ (+ m1 m2))))
         (d (* (- m2 m1) (/ (+ m1 m2)))))
    (declare (double-float m1 m2 v1 v2 power-of-ten))
    (loop for i double-float from 0d0
          until (<= 0d0 v1 v2)
          do (if (minusp v1)
                 (setf v1 (- v1))
                 (psetf v1 (+ (* v1 a)
                              (* v2 b))
                        v2 (+ (* v1 c)
                              (* v2 d))))
          finally (return (/ i power-of-ten)))))
